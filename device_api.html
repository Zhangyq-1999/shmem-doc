

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DEVICE API &mdash; SHMEM Guidebook 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=d6bf9227" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SHMEM Python API" href="pythonAPI.html" />
    <link rel="prev" title="HOST API" href="host_api.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            SHMEM Guidebook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="related_scripts.html">相关脚本</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using ACLSHMEM</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_demo.html">SHMEM API 样例</a></li>
<li class="toctree-l1"><a class="reference internal" href="compilation_build_guide.html">编译与构建</a></li>
<li class="toctree-l1"><a class="reference internal" href="log_debug.html">SHMEM日志</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="def.html">SHMEM DEF</a></li>
<li class="toctree-l1"><a class="reference internal" href="host_api.html">HOST API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DEVICE API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-amo-h">shmem_device_amo.h</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TYPE_FUNC_ATOMIC_INT"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_INT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_ATOMIC_ADD_TYPENAME"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv429ACLSHMEM_TYPE_FUNC_ATOMIC_INT28ACLSHMEM_ATOMIC_ADD_TYPENAME"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_INT()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv431ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT34ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-cc-h">shmem_device_cc.h</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-mo-h">shmem_device_mo.h</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-p2p-sync-h">shmem_device_p2p_sync.h</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_ALL"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_ALL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_ANY"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_ANY</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_SOME"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_SOME</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_ALL_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_ALL_VECTOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_ANY_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_ANY_VECTOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_WAIT_UNTIL_SOME_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_WAIT_UNTIL_SOME_VECTOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_ANY"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_ANY</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_SOME"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_SOME</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_ALL_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_ALL_VECTOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_ANY_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_ANY_VECTOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_SOME_VECTOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_SOME_VECTOR</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-rma-h">shmem_device_rma.h</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TYPE_FUNC"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPE_FUNC</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TEST_TYPE_FUNC"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TEST_TYPE_FUNC</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TYPENAME_P_AICORE"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPENAME_P_AICORE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_TYPENAME_G_AICORE"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_TYPENAME_G_AICORE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_SIZE_MEM"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_SIZE_MEM</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_SIZE_MEM"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_SIZE_MEM</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_SIZE_MEM_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_SIZE_MEM_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_TENSOR_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_TENSOR_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_SIZE_MEM_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_SIZE_MEM_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-so-h">shmem_device_so.h</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED_NBI</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED_NBI"><code class="docutils literal notranslate"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED_NBI</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shmem-device-team-h">shmem_device_team.h</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pythonAPI.html">SHMEM Python API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example.html">初始化</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html#allgather">AllGather</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Architecture</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="principles.html">SHMEM原理概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="code_organization.html">代码组织结构</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Troubleshooting And FAQs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Troubleshooting_FAQs.html">SHMEM 使用限制</a></li>
<li class="toctree-l1"><a class="reference internal" href="Troubleshooting_FAQs.html#id1">SHMEM 常见问题</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Security harding and public IP address</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="SECURITY.html">安全声明</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SHMEM Guidebook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">DEVICE API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/device_api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="device-api">
<h1>DEVICE API<a class="headerlink" href="#device-api" title="Link to this heading"></a></h1>
<section id="shmem-device-amo-h">
<h2>shmem_device_amo.h<a class="headerlink" href="#shmem-device-amo-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TYPE_FUNC_ATOMIC_INT">
<span class="target" id="shmem__device__amo_8h_1a0524f47994c33f3e9ceca90b6ea274b5"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_INT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TYPE_FUNC_ATOMIC_INT" title="Link to this definition"></a><br /></dt>
<dd><p>Standard Atomic Add Types and Names. </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int8   </p></td>
<td><p>int8    </p></td>
</tr>
<tr class="row-odd"><td><p>int16   </p></td>
<td><p>int16    </p></td>
</tr>
<tr class="row-even"><td><p>int32   </p></td>
<td><p>int32   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT">
<span class="target" id="shmem__device__amo_8h_1a0240a88ad2738ea85c36120277d17513"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT" title="Link to this definition"></a><br /></dt>
<dd><p>Standard Atomic Add Types and Names. </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>half   </p></td>
<td><p>half    </p></td>
</tr>
<tr class="row-odd"><td><p>float   </p></td>
<td><p>float   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_ATOMIC_ADD_TYPENAME">
<span class="target" id="shmem__device__amo_8h_1ae51a6e89b8bd6650cd5b5e1dfedb15f5"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">ATOMIC_TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_ATOMIC_ADD_TYPENAME" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem atomic add functions for different data types (e.g., int8, int16, int32). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><dl>
<dt class="sig sig-object cpp">
<em><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_NAME_atomic_add(__gm__</span> <span class="pre">TYPE</span> <span class="pre">*dst,</span> <span class="pre">TYPE</span> <span class="pre">value,</span> <span class="pre">int32_t</span> <span class="pre">pe):</span></em></dt>
<dd></dd></dl>

</p>
<p><dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Perform contiguous data atomic add operation on symmetric memory from the specified PE to address on the local PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>value</strong> - [in] Value atomic add to destination.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT">
<span class="target" id="shmem__device__amo_8h_1a760e21f56e159d927fc6075759a1cb71"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">ATOMIC_TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem atomic add functions for different data types (e.g., float, half). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><dl>
<dt class="sig sig-object cpp">
<em><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_NAME_atomic_add(__gm__</span> <span class="pre">TYPE</span> <span class="pre">*dst,</span> <span class="pre">TYPE</span> <span class="pre">value,</span> <span class="pre">int32_t</span> <span class="pre">pe):</span></em></dt>
<dd></dd></dl>

</p>
<p><dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Perform contiguous data atomic add operation on symmetric memory from the specified PE to address on the local PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>value</strong> - [in] Value atomic add to destination.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429ACLSHMEM_TYPE_FUNC_ATOMIC_INT28ACLSHMEM_ATOMIC_ADD_TYPENAME">
<span id="_CPPv329ACLSHMEM_TYPE_FUNC_ATOMIC_INT28ACLSHMEM_ATOMIC_ADD_TYPENAME"></span><span id="_CPPv229ACLSHMEM_TYPE_FUNC_ATOMIC_INT28ACLSHMEM_ATOMIC_ADD_TYPENAME"></span><span id="ACLSHMEM_TYPE_FUNC_ATOMIC_INT__ACLSHMEM_ATOMIC_ADD_TYPENAME"></span><span class="target" id="shmem__device__amo_8h_1aa5d75da4e30b4ecb7f49c4f10ad74cc9"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_INT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429ACLSHMEM_TYPE_FUNC_ATOMIC_INT28ACLSHMEM_ATOMIC_ADD_TYPENAME" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT34ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT">
<span id="_CPPv331ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT34ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT"></span><span id="_CPPv231ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT34ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT"></span><span id="ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT__ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT"></span><span class="target" id="shmem__device__amo_8h_1a2365191dee9f4feb1b64808893305582"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431ACLSHMEM_TYPE_FUNC_ATOMIC_FLOAT34ACLSHMEM_ATOMIC_ADD_TYPENAME_FLOAT" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

</div>
</section>
<section id="shmem-device-cc-h">
<h2>shmem_device_cc.h<a class="headerlink" href="#shmem-device-cc-h" title="Link to this heading"></a></h2>
<p>shmem device Collective Communication APIs </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__cc_8h_1aef6b992c3031eafd82a40f7d842b0763"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">util_set_ffts_config</span> <span class="pre">(uint64_t</span> <span class="pre">config)</span></span></dt>
<dd><p>Set runtime ffts address. Call this at MIX Kernel entry point (if the kernel contains barrier calls). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>config</strong> – [config] ffts config, acquired by <a class="reference internal" href="host_api.html#shmem__host__p2p__sync_8h_1a5ef21d69da0ca953dfb886b67b18d6ea"><span class="std std-ref">util_get_ffts_config()</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__host__cc_8h_1acc976a131b57626f4feb2aedcccc4240"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_barrier</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team)</span></span></dt>
<dd><p>aclshmem_barrier is a collective synchronization routine over a team. Control returns from aclshmem_barrier after all PEs in the team have called aclshmem_barrier. aclshmem_barrier ensures that all previously issued stores and remote memory updates, including AMOs and RMA operations, done by any of the PEs in the active set are complete before returning. On systems with only scale-up network (HCCS), updates are globally visible, whereas on systems with both scale-up network HCCS and scale-out network (RDMA), ACLSHMEM only guarantees that updates to the memory of a given PE are visible to that PE. Barrier operations issued on the CPU and the NPU only complete communication operations that were issued from the CPU and the NPU, respectively. To ensure completion of GPU-side operations from the CPU, using aclrtSynchronizeStream/aclrtDeviceSynchronize or stream-based API. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>team</strong> – [in] team to do barrier</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__host__cc_8h_1aead514d1024c322c0d7e60f6cfc75a22"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_barrier_all</span> <span class="pre">(void)</span></span></dt>
<dd><p>aclshmem_barrier of all PEs. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__cc_8h_1a674f0c1c99fed9747b0e798ca9e12347"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_barrier_vec</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team)</span></span></dt>
<dd><p>Similar to aclshmem_barrier except that only vector cores participate. Useful in communication-over-compute operators. Cube core may call the api but takes no effect. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>team</strong> – [in] team to do barrier </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__cc_8h_1a58a3f0b69a7ed7ffb5984cdef49b57ed"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_barrier_all_vec</span> <span class="pre">(void)</span></span></dt>
<dd><p>aclshmemx_barrier_vec of all PEs. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__cc_8h_1a8917a98f62b512e9fa874a67ccd97df6"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_sync</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team)</span></span></dt>
<dd><p>Similar to aclshmem_barrier. In constract with the aclshmem_barrier routine, aclshmem_sync only ensures completion and visibility of previously issued memory stores and does not ensure completion of remote memory updates issued via ACLSHMEM rountines. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>team</strong> – [in] team to do barrier </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__cc_8h_1ae2359cf78f29722a9523e099e6e1220d"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_sync_all</span> <span class="pre">(void)</span></span></dt>
<dd><p>aclshmem_sync_all of all PEs. </p>
</dd></dl>

</div>
</section>
<section id="shmem-device-mo-h">
<h2>shmem_device_mo.h<a class="headerlink" href="#shmem-device-mo-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__mo_8h_1ac9bd98e283fca88c486bbf8435982353"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_quiet</span> <span class="pre">(void)</span></span></dt>
<dd><p>The aclshmem_quiet routine ensures completion of all operations on symmetric data objects issued by the calling PE. On systems with only scale-up network (HCCS), updates are globally visible, whereas on systems with both scale-up network HCCS and scale-out network (RDMA), ACLSHMEM only guarantees that updates to the memory of a given PE are visible to that PE. Quiet operations issued on the CPU and the NPU only complete communication operations that were issued from the CPU and the NPU, respectively. To ensure completion of GPU-side operations from the CPU, using aclrtSynchronizeStream/aclrtDeviceSynchronize or stream-based API. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__mo_8h_1a493640d71e8d04347db4fc81f41bbce3"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_fence</span> <span class="pre">(void)</span></span></dt>
<dd><p>In OpenACLSHMEM specification, aclshmem_fence assures ordering of delivery of Put, AMOs, and memory store routines to symmetric data objects, but does not guarantee the completion of these operations. However, due to hardware capabilities, we implemented aclshmem_fence same as aclshmem_quiet, ensuring both ordering and completion. Fence operations issued on the CPU and the NPU only order communication operations that were issued from the CPU and the NPU, respectively. To ensure completion of GPU-side operations from the CPU, using aclrtSynchronizeStream/aclrtDeviceSynchronize or stream-based API. </p>
</dd></dl>

</div>
</section>
<section id="shmem-device-p2p-sync-h">
<h2>shmem_device_p2p_sync.h<a class="headerlink" href="#shmem-device-p2p-sync-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL">
<span class="target" id="shmem__device__p2p__sync_8h_1afe542e0f29ba78a3d100cd0e900e4f28"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_wait_until(<strong>gm</strong> TYPE *ivar, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until the value at ivar satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of a remotely accessible data object. The type of ivar should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivar with cmp_val. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivar. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT">
<span class="target" id="shmem__device__p2p__sync_8h_1a1291b9abc4b82b2f5345831d48b6be51"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_wait(<strong>gm</strong> TYPE *ivar, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until the value of ivar is not equal to comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of a remotely accessible data object. The type of ivar should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivar. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_ALL">
<span class="target" id="shmem__device__p2p__sync_8h_1a85068e425fb90d2182902a4c51e02d9c"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_ALL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_ALL" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until all functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_wait_until_all(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until all entries in the wait set specified by ivars and status satisfy the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of a remotely accessible data object. The type of ivar should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivar with cmp_val. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivar. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_ANY">
<span class="target" id="shmem__device__p2p__sync_8h_1ad9494979e3e5a165725b753aad8d53d1"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_ANY</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_ANY" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until any functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_wait_until_any(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until any one entry in the wait set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivar with cmp_val. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivar. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the index of an element in the ivars array that satisfies the wait condition. If the wait set is empty, this routine returns SIZE_MAX. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_SOME">
<span class="target" id="shmem__device__p2p__sync_8h_1acab7186d1f0cbeb8beee567fa64231de"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_SOME</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_SOME" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until some functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_wait_until_some(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> size_t *indices, <strong>gm</strong> const int *status, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until at least one entry in the wait set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>indices</strong> - [out] Local address of an array of indices of length at least nelems into ivars that satisfied the wait condition.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivar. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the number of indices returned in the indices array. If the wait set is empty, this routine returns 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_ALL_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1a08327c297da9ea8462e702333d4a5110"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_ALL_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_ALL_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until all vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_wait_until_all_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until all entries in the wait set specified by ivars and status satisfy the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_ANY_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1a7f653a68e1e49bc66690f1ef9f12b626"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_ANY_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_ANY_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until any vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_wait_until_any_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until any one entry in the wait set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the index of an element in the ivars array that satisfies the wait condition. If the wait set is empty, this routine returns SIZE_MAX. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_WAIT_UNTIL_SOME_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1a4eaa388afd20e6a79c7bd8ab580c53cd"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_WAIT_UNTIL_SOME_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_WAIT_UNTIL_SOME_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem wait until some vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_wait_until_some_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> size_t *indices, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by blocking until at least one entry in the wait set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>indices</strong> - [out] Local address of an array of indices of length at least nelems into ivars that satisfied the wait condition.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the number of indices returned in the indices array. If the wait set is empty, this routine returns 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST">
<span class="target" id="shmem__device__p2p__sync_8h_1a5bfe983183d66fcc54437af4e7a4ed8c"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE int aclshmem_NAME_test(<strong>gm</strong> TYPE *ivars, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether the value of ivar satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value against which the object pointed to by ivar will be compared. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return 1 if the comparison (via the operator cmp) between the ivar and cmp_value results in true; otherwise, return 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_ANY">
<span class="target" id="shmem__device__p2p__sync_8h_1aabdc8c8ed980e69da3332721ef996baf"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_ANY</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_ANY" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test any functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_test_any(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether any one entry in the test set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the wait set; If status[i] != 0, then ivars[i] is excluded from the wait set; If status is NULL, all elements of ivars are included in the wait set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivars. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the index of an element in the ivars array that satisfies the test condition. If the test set is empty or no conditions in the test set are satisfied, this routine returns SIZE_MAX. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_SOME">
<span class="target" id="shmem__device__p2p__sync_8h_1a53310944eb171df556e789fc2ab30aeb"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_SOME</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_SOME" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test some functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_test_some(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> size_t *indices, <strong>gm</strong> const int *status, int cmp, TYPE cmp_value)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether at least one entry in the test set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_value.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>indices</strong> - [out] Local address of an array of indices of length at least nelems into ivars that satisfied the test condition.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the test set; If status[i] != 0, then ivars[i] is excluded from the test set; If status is NULL, all elements of ivars are included in the test set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_value</strong> - [in] The value to be compared with ivars. The type of cmp_value should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the number of indices returned in the indices array. If the test set is empty, this routine returns 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_ALL_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1ab99d978d90fe2e19ab49794c23be1a28"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_ALL_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_ALL_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test all vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_test_all_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether all entries in the test set specified by ivars and status satisfy the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the test set; If status[i] != 0, then ivars[i] is excluded from the test set; If status is NULL, all elements of ivars are included in the test set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return 1 if all elements in ivars satisfy the test conditions or if nelems is 0, otherwise this routine returns 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_ANY_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1a9113993bc338f84edafec540e48ac232"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_ANY_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_ANY_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test any vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_test_any_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether any one entry in the test set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the test set; If status[i] != 0, then ivars[i] is excluded from the test set; If status is NULL, all elements of ivars are included in the test set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the index of an element in the ivars array that satisfies the test condition. If the test set is empty or no conditions in the test set are satisfied, this routine returns SIZE_MAX. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_SOME_VECTOR">
<span class="target" id="shmem__device__p2p__sync_8h_1a691d5b968833281ec2c3c1b0e9902675"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_SOME_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_SOME_VECTOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem test some vector functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE size_t aclshmem_NAME_test_some_vector(<strong>gm</strong> TYPE *ivars, size_t nelems, <strong>gm</strong> size_t *indices, <strong>gm</strong> const int *status, int cmp, <strong>gm</strong> TYPE *cmp_values)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Implements point-to-point synchronization by testing whether at least one entry in the test set specified by ivars and status satisfies the condition defined by the comparison operator, cmp, and comparison value, cmp_values.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>ivar</strong> - [in] Symmetric address of an array of remotely accessible data objects. The type of ivars should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
<li><p><strong>nelems</strong> - [in] The number of elements in the ivars array.</p></li>
<li><p><strong>indices</strong> - [out] Local address of an array of indices of length at least nelems into ivars that satisfied the test condition.</p></li>
<li><p><strong>status</strong> - [in] Local address of an optional mask array of length nelems. If status[i] == 0, then ivars[i] is included in the test set; If status[i] != 0, then ivars[i] is excluded from the test set; If status is NULL, all elements of ivars are included in the test set.</p></li>
<li><p><strong>cmp</strong> - [in] The comparison operator that compares ivars with cmp_value. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE.</p></li>
<li><p><strong>cmp_values</strong> - [in] Local address of an array of length nelems containing values to be compared with the respective value in ivars. The type of cmp_values should match that implied in the ACLSHMEM_P2P_SYNC_TYPE_FUNC.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Return the number of indices returned in the indices array. If the test set is empty, this routine returns 0. </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__p2p__sync_8h_1add61608f1fae01e6a6960c0f18b524f3"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_signal_op</span> <span class="pre">(__gm__</span> <span class="pre">int32_t</span> <span class="pre">*sig_addr,</span> <span class="pre">int32_t</span> <span class="pre">signal,</span> <span class="pre">int</span> <span class="pre">sig_op,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>The aclshmemx_signal_op operation updates sig_addr with signal using operation sig_op on the specified PE. This operation can be used together with aclshmem_signal_wait_until for efficient point-to-point synchronization. WARNING: Atomicity NOT Guaranteed. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig_addr</strong> – [in] Symmetric address of the signal word to be updated. </p></li>
<li><p><strong>signal</strong> – [in] The value used to update sig_addr. </p></li>
<li><p><strong>sig_op</strong> – [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__p2p__sync_8h_1a0a384caec8f5ab245f4e072dcc74cc29"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int32_t</span> <span class="pre">aclshmem_signal_wait_until</span> <span class="pre">(__gm__</span> <span class="pre">int32_t</span> <span class="pre">*sig_addr,</span> <span class="pre">int</span> <span class="pre">cmp,</span> <span class="pre">int32_t</span> <span class="pre">cmp_val)</span></span></dt>
<dd><p>This routine can be used to implement point-to-point synchronization between PEs or between threads within the same PE. A call to this routine blocks until the value of sig_addr at the calling PE satisfies the wait condition specified by the comparison operator, cmp, and comparison value, cmp_val. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig_addr</strong> – [in] Local address of the source signal variable. </p></li>
<li><p><strong>cmp</strong> – [in] The comparison operator that compares sig_addr with cmp_val. Supported operators: ACLSHMEM_CMP_EQ/ACLSHMEM_CMP_NE/ACLSHMEM_CMP_GT/ ACLSHMEM_CMP_GE/ACLSHMEM_CMP_LT/ACLSHMEM_CMP_LE. </p></li>
<li><p><strong>cmp_val</strong> – [in] The value against which the object pointed to by sig_addr will be compared. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Return the contents of the signal data object, sig_addr, at the calling PE that satisfies the wait condition. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="shmem-device-rma-h">
<h2>shmem_device_rma.h<a class="headerlink" href="#shmem-device-rma-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TYPE_FUNC">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1abadf2954fce3634ed8300ca5107b5475"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TYPE_FUNC" title="Link to this definition"></a><br /></dt>
<dd><p>Standard RMA Types and Names. </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>half   </p></td>
<td><p>half    </p></td>
</tr>
<tr class="row-odd"><td><p>float   </p></td>
<td><p>float    </p></td>
</tr>
<tr class="row-even"><td><p>double   </p></td>
<td><p>double    </p></td>
</tr>
<tr class="row-odd"><td><p>int8   </p></td>
<td><p>int8    </p></td>
</tr>
<tr class="row-even"><td><p>int16   </p></td>
<td><p>int16    </p></td>
</tr>
<tr class="row-odd"><td><p>int32   </p></td>
<td><p>int32    </p></td>
</tr>
<tr class="row-even"><td><p>int64   </p></td>
<td><p>int64    </p></td>
</tr>
<tr class="row-odd"><td><p>uint8   </p></td>
<td><p>uint8    </p></td>
</tr>
<tr class="row-even"><td><p>uint16   </p></td>
<td><p>uint16    </p></td>
</tr>
<tr class="row-odd"><td><p>uint32   </p></td>
<td><p>uint32    </p></td>
</tr>
<tr class="row-even"><td><p>uint64   </p></td>
<td><p>uint64    </p></td>
</tr>
<tr class="row-odd"><td><p>char   </p></td>
<td><p>char    </p></td>
</tr>
<tr class="row-even"><td><p>bfloat16   </p></td>
<td><p>bfloat16   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TEST_TYPE_FUNC">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a92ac0328c3c8786408005308615c8db0"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TEST_TYPE_FUNC</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TEST_TYPE_FUNC" title="Link to this definition"></a><br /></dt>
<dd><p>Standard test Types and Names. </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>float   </p></td>
<td><p>float    </p></td>
</tr>
<tr class="row-odd"><td><p>int8   </p></td>
<td><p>int8    </p></td>
</tr>
<tr class="row-even"><td><p>int16   </p></td>
<td><p>int16    </p></td>
</tr>
<tr class="row-odd"><td><p>int32   </p></td>
<td><p>int32    </p></td>
</tr>
<tr class="row-even"><td><p>int64   </p></td>
<td><p>int64    </p></td>
</tr>
<tr class="row-odd"><td><p>uint8   </p></td>
<td><p>uint8    </p></td>
</tr>
<tr class="row-even"><td><p>uint16   </p></td>
<td><p>uint16    </p></td>
</tr>
<tr class="row-odd"><td><p>uint32   </p></td>
<td><p>uint32    </p></td>
</tr>
<tr class="row-even"><td><p>uint64   </p></td>
<td><p>uint64    </p></td>
</tr>
<tr class="row-odd"><td><p>char   </p></td>
<td><p>char   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TYPENAME_P_AICORE">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a61335f3c5f1cf43822edf3a8bff54492"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPENAME_P_AICORE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TYPENAME_P_AICORE" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem p functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_p(<strong>gm</strong> TYPE *dst, const TYPE value, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Provide a low latency put capability for single element of most basic types.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Symmetric address of the destination data on local PE.</p></li>
<li><p><strong>value</strong> - [in] The element to be put.</p></li>
<li><p><strong>pe</strong> - [in] The number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_TYPENAME_G_AICORE">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a82ad53d5fe3c3bee2331140f8780eb63"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPENAME_G_AICORE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_TYPENAME_G_AICORE" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem g functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_g(<strong>gm</strong> TYPE *dst, const TYPE value, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Provide a low latency get capability for single element of most basic types.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>src</strong> - [in] Symmetric address of the destination data on local PE.</p></li>
<li><p><strong>pe</strong> - [in] The number of the remote PE.</p></li>
</ul>
</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>A single element of type specified in the input pointer. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1aa54404168577ccbd84bdec6b9d0f15a5"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_SIZE_MEM">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ae4b89fee8d394fd3e3955e9ca6234181"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_SIZE_MEM</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">BITS</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_SIZE_MEM" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get functions for different bits (e.g., 8, 16). The macro parameters: BITS is the bits. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_getBITS(<strong>gm</strong> void *dst, <strong>gm</strong> void *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ac2f08931f80ffbaecfa8117711abb244"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy a contiguous data on local PE to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local device of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_SIZE_MEM">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ab00d01396862ae28d4cd8bcd44632ae0"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_SIZE_MEM</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">BITS</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_SIZE_MEM" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put functions for different bits (e.g., 8, 16). The macro parameters: BITS is the bits. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_putBITS(<strong>gm</strong> void *dst, <strong>gm</strong> void *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy a contiguous data on local PE to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local device of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ae03fc3e04ab9a054e7410792f7a43158"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_SIZE_MEM_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ad0c5a96bf2e246ab4edfbf37152aff57"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_SIZE_MEM_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">BITS</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_SIZE_MEM_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get functions for different bits (e.g., 8, 16). The macro parameters: BITS is the bits. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_getBITS_nbi(<strong>gm</strong> void *dst, <strong>gm</strong> void *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_DETAILED_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a05b17c2b1265df22a2cc87fd46d0d8ad"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local device.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ac2ee86555406b9421b11fb21241c5c5d"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_TENSOR_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_DETAILED_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a64a1a6cf8518cd916d8246b28d18a8f6"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_TENSOR_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_TENSOR_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local device.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a04c6a530d7f7047e4a14a97dee9ebc20"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local device of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_SIZE_MEM_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a779348ca7293edd3d40759b04dfdb18b"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_SIZE_MEM_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">BITS</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_SIZE_MEM_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put functions for different bits (e.g., 8, 16). The macro parameters: BITS is the bits. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_putBITS_nbi(<strong>gm</strong> void *dst, <strong>gm</strong> void *src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local device of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_DETAILED_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a56b332415b46386f3c171f206cb2b3d9"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local PE to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local device of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a72a2f4a78e88e2a041d0d6a533c57546"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, uint32_t elem_size, int32_t pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on local device of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_DETAILED_NBI">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a6f863188dd13c155d0930959411b869b"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_TENSOR_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, const non_contiguous_copy_param &amp;copy_params, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local PE to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on local device of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ae91d23e12445c181b3f13567feeb7f92"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_getmem</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int32_t</span> <span class="pre">pe)</span></span></dt>
<dd><p>Synchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ad88fd0766884ca7a19387a6e96dc5041"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_putmem</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int32_t</span> <span class="pre">pe)</span></span></dt>
<dd><p>Synchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1ab2562bfe0be972daec68806a1fabaf2a"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_getmem_nbi</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int32_t</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1a19afd9518bb2156da44fed08de02d093"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_putmem_nbi</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int32_t</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2shmem__device__rma_8h_1aa9a879064d412175925c3f63acf1b17c"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_set_mte_config</span> <span class="pre">(uint64_t</span> <span class="pre">offset,</span> <span class="pre">uint32_t</span> <span class="pre">ub_size,</span> <span class="pre">uint32_t</span> <span class="pre">event_id)</span></span></dt>
<dd><p>Set necessary parameters for put or get. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>offset</strong> – [in] The start address on UB. </p></li>
<li><p><strong>ub_size</strong> – [in] The Size of Temp UB Buffer. </p></li>
<li><p><strong>event_id</strong> – [in] Sync ID for put or get. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1abadf2954fce3634ed8300ca5107b5475"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Standard RMA Types and Names. </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>half   </p></td>
<td><p>half    </p></td>
</tr>
<tr class="row-odd"><td><p>float   </p></td>
<td><p>float    </p></td>
</tr>
<tr class="row-even"><td><p>double   </p></td>
<td><p>double    </p></td>
</tr>
<tr class="row-odd"><td><p>int8   </p></td>
<td><p>int8    </p></td>
</tr>
<tr class="row-even"><td><p>int16   </p></td>
<td><p>int16    </p></td>
</tr>
<tr class="row-odd"><td><p>int32   </p></td>
<td><p>int32    </p></td>
</tr>
<tr class="row-even"><td><p>int64   </p></td>
<td><p>int64    </p></td>
</tr>
<tr class="row-odd"><td><p>uint8   </p></td>
<td><p>uint8    </p></td>
</tr>
<tr class="row-even"><td><p>uint16   </p></td>
<td><p>uint16    </p></td>
</tr>
<tr class="row-odd"><td><p>uint32   </p></td>
<td><p>uint32    </p></td>
</tr>
<tr class="row-even"><td><p>uint64   </p></td>
<td><p>uint64    </p></td>
</tr>
<tr class="row-odd"><td><p>char   </p></td>
<td><p>char    </p></td>
</tr>
<tr class="row-even"><td><p>bfloat16   </p></td>
<td><p>bfloat16   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_UB_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1aeaebdff97610e38164a774c9c3ce5a5a"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(<strong>ubuf</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local UB. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local UB of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1a54bb0e6f1dac40ef12fc898f65bd836f"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(AscendC::LocalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, uint32_t elem_size, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local UB.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] LocalTensor on local UB of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_UB_DETAILED_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1a38ccac62df0899c6547685aac324ee39"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(<strong>ubuf</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local UB.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local UB of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1a95d2e7d39684787ff116ecfc619e7ed1"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_GET_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem get nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_get_nbi(AscendC::LocalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, const non_contiguous_copy_param &amp;copy_params, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local UB.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] LocalTensor on local UB of the destination data.</p></li>
<li><p><strong>src</strong> - [in] GlobalTensor on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is managed in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_UB_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1a4a055d5af140af44e227099e772170e1"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(<strong>ubuf</strong> TYPE *dst, <strong>gm</strong> TYPE *src, uint32_t elem_size, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on local UB to symmetric address on the specified PE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local UB of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1ad1c1eadda6c82c47d19fad7a9ca1cb68"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(AscendC::LocalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, uint32_t elem_size, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy contiguous data on local UB to symmetric address on the specified PE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] LocalTensor on local UB of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the destination and source arrays.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_UB_DETAILED_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1a99bde469bb2bcefbbfe5e9e221ee746d"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(<strong>ubuf</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on local UB of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI">
<span class="target" id="ub2gm_2shmem__device__rma_8h_1aa0c8ebbe4f26419091fdaf9538768238"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_UB_TENSOR_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_nbi(AscendC::LocalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, const non_contiguous_copy_param &amp;copy_params, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] GlobalTensor on Symmetric memory of the destination data.</p></li>
<li><p><strong>src</strong> - [in] LocalTensor on local UB of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1a0cd3eea6ce6b2636fdbd238a135bfd6c"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(__ubuf__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local UB. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local UB of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1add625e96d20686d5cd83757882421ed6"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local UB. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] LocalTensor on local UB of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1ae4a871450a6e3a2ad77a94820e421275"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(__ubuf__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local UB. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local UB of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1a607fa58dd2467c349c656672a7d3f416"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local UB. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] LocalTensor on local UB of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on Symmetric memory of the source data. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1a2bf65a3a71a3c01fd645e569730fa3f0"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local UB to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on local UB of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1a8151fea4108d78e82b282ea59f43b533"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local UB to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] LocalTensor on local UB of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1a84de65f5dcf8383fd4ac78194f0957ce"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on local UB of the source data. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="ub2gm_2engine_2shmem__device__mte_8h_1ae7b3a97627aaaf88246452876ac11ecf"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] LocalTensor on local UB of the source data. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1abb516a9bdc39f4999e805bd04cf8daa8"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">aclshmem_ptr</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Translate an local symmetric address to remote symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – [in] Symmetric address on local PE. </p></li>
<li><p><strong>pe</strong> – [in] The number of the remote PE. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A remote symmetric address on the specified PE that can be accessed using memory loads and stores. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1abd5356c4a284db4aaa219f82ce913590"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">ub_size,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB. </p></li>
<li><p><strong>ub_size</strong> – [in] The size of temp Buffer on UB. (In Bytes) </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1a151c116d3126258da8de1df34a99637f"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">ub_size,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB. </p></li>
<li><p><strong>ub_size</strong> – [in] The size of temp Buffer on UB. (In Bytes) </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is managed in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1a44397bb40ee260db1fc2ebbbc90fbac0"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] LocalTensor on local UB. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1a625fafbb411c97c37ce93bb53bbb7b86"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_get_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on symmetric memory from the specified PE to address on the local device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] LocalTensor on local UB. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1a80c43e9fb278a7aaa025d87d7cc4605c"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">ub_size,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB. </p></li>
<li><p><strong>ub_size</strong> – [in] The size of temp Buffer on UB. (In Bytes) </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1a86399212a974de0c8e0e3ded9f36b33e"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">ub_size,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB. </p></li>
<li><p><strong>ub_size</strong> – [in] The size of temp Buffer on UB. (In Bytes) </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1afba290b9e4eaad9a6fff5f4d6ef97d4f"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="gm2gm_2engine_2shmem__device__mte_8h_1ae7228644b14efbfc8fa4add2671fe1fd"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_mte_put_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">const</span> <span class="pre">non_contiguous_copy_param</span> <span class="pre">&amp;copy_params,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local PE to symmetric address on the specified PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] LocalTensor on local UB. </p></li>
<li><p><strong>copy_params</strong> – [in] Params to describe how non-contiguous data is organized in src and dst. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__rdma_8h_1a8305121babdff1069366ca322c5725b1"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">aclshmem_roce_ptr</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Translate an local symmetric address to remote symmetric address on the specified PE used by RDMA. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ptr</strong> – [in] Symmetric address on local PE. </p></li>
<li><p><strong>pe</strong> – [in] The number of the remote PE. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A remote symmetric address on the specified PE that can be accessed using memory loads and stores. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__rdma_8h_1a4fb332d61c8b4d71ad0f87f6725cbe41"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_roce_get_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local device. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB, available space larger than 64 Bytes. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__rdma_8h_1a28b394afbe38ea90150df26b264d794e"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_roce_get_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on symmetric memory from the specified PE to address on the local PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on Symmetric memory of the source data. </p></li>
<li><p><strong>buf</strong> – [in] LocalTensor on local UB, available space larger than 64 Bytes. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__rdma_8h_1ae129138a43118f5ba8dcc35d0866e309"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_roce_put_nbi</span> <span class="pre">(__gm__</span> <span class="pre">T</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">__ubuf__</span> <span class="pre">T</span> <span class="pre">*buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB, available space larger than 64 Bytes. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__rdma_8h_1a0d7cc237b21b692c88fadd5ef6ebe502"></span><span class="sig-name descname"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmemx_roce_put_nbi</span> <span class="pre">(AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">dst,</span> <span class="pre">AscendC::GlobalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">src,</span> <span class="pre">AscendC::LocalTensor&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">buf,</span> <span class="pre">uint32_t</span> <span class="pre">elem_size,</span> <span class="pre">int</span> <span class="pre">pe,</span> <span class="pre">AscendC::TEventID</span> <span class="pre">EVENT_ID)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE. WARNING: When using RDMA as the underlying transport, concurrent RMA/AMO operations to the same PE are not supported. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] GlobalTensor on Symmetric memory of the destination data. </p></li>
<li><p><strong>src</strong> – [in] GlobalTensor on local device of the source data. </p></li>
<li><p><strong>buf</strong> – [in] Pointer on local UB, available space larger than 64 Bytes. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the destination and source arrays. </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
<li><p><strong>EVENT_ID</strong> – [in] ID used to Sync MTE2\MTE3 Event. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="shmem-device-so-h">
<h2>shmem_device_so.h<a class="headerlink" href="#shmem-device-so-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__so_8h_1abadf2954fce3634ed8300ca5107b5475"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_TYPE_FUNC</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FUNC</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Standard RMA Types and Names. </p>
<p> * Copyright (c) 2025 Huawei Technologies Co., Ltd.  * This program is free software, you can redistribute it and/or modify it under the terms and conditions of  * CANN Open Software License Agreement Version 2.0 (the “License”).  * Please refer to the License for details. You may not use this file except in compliance with the License.  * THIS SOFTWARE IS PROVIDED ON AN “AS IS” BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,  * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.  * See LICENSE in the root of the software repository for the full text of the License.   </p>
<p><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NAME   </p></th>
<th class="head"><p>TYPE    </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>half   </p></td>
<td><p>half    </p></td>
</tr>
<tr class="row-odd"><td><p>float   </p></td>
<td><p>float    </p></td>
</tr>
<tr class="row-even"><td><p>double   </p></td>
<td><p>double    </p></td>
</tr>
<tr class="row-odd"><td><p>int8   </p></td>
<td><p>int8    </p></td>
</tr>
<tr class="row-even"><td><p>int16   </p></td>
<td><p>int16    </p></td>
</tr>
<tr class="row-odd"><td><p>int32   </p></td>
<td><p>int32    </p></td>
</tr>
<tr class="row-even"><td><p>int64   </p></td>
<td><p>int64    </p></td>
</tr>
<tr class="row-odd"><td><p>uint8   </p></td>
<td><p>uint8    </p></td>
</tr>
<tr class="row-even"><td><p>uint16   </p></td>
<td><p>uint16    </p></td>
</tr>
<tr class="row-odd"><td><p>uint32   </p></td>
<td><p>uint32    </p></td>
</tr>
<tr class="row-even"><td><p>uint64   </p></td>
<td><p>uint64    </p></td>
</tr>
<tr class="row-odd"><td><p>char   </p></td>
<td><p>char    </p></td>
</tr>
<tr class="row-even"><td><p>bfloat16   </p></td>
<td><p>bfloat16   </p></td>
</tr>
</tbody>
</table>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL">
<span class="target" id="shmem__device__so_8h_1af8c85c1798d55a0fbb0c99a3e3153f47"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, size_t elem_size, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy a contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR">
<span class="target" id="shmem__device__so_8h_1a20fb7556be2377abe279b81f4af4fe9b"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, size_t elem_size, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Copy a contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED">
<span class="target" id="shmem__device__so_8h_1a891efce0af65c8b41a7386f8d64f280c"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE then update sig_addr</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED">
<span class="target" id="shmem__device__so_8h_1adbe7251f92d79718dea8124c28b3adab"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src，const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Synchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_NBI">
<span class="target" id="shmem__device__so_8h_1a8fda7bc245497043b10b4a7b0234cda9"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal_nbi(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, size_t elem_size, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy a contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_NBI">
<span class="target" id="shmem__device__so_8h_1ac1b7a98f3565e754aae27f7ecee96060"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal nbi functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal_nbi(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src, size_t elem_size, size_t elem_size, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Copy a contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>elem_size</strong> - [in] Number of elements in the dest and source arrays.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED_NBI">
<span class="target" id="shmem__device__so_8h_1a96ea04be827d50eb6e8f66509f9fed5e"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(<strong>gm</strong> TYPE *dst, <strong>gm</strong> TYPE *src, const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE then update sig_addr</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED_NBI">
<span class="target" id="shmem__device__so_8h_1aa8b61cfc741fdf11381151eb0d06cea3"></span><span class="sig-name descname"><span class="n"><span class="pre">ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED_NBI</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">NAME</span></span>, <span class="n"><span class="pre">TYPE</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ACLSHMEM_PUT_TYPENAME_MEM_SIGNAL_TENSOR_DETAILED_NBI" title="Link to this definition"></a><br /></dt>
<dd><p>Automatically generates aclshmem put signal functions for different data types (e.g., float, int8_t). The macro parameters: NAME is the function name suffix, TYPE is the operation data type. </p>
<p><div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>ACLSHMEM_DEVICE void aclshmem_NAME_put_signal(AscendC::GlobalTensor&lt;TYPE&gt; dst, AscendC::GlobalTensor&lt;TYPE&gt; src，const <a class="reference internal" href="def.html#structnon__contiguous__copy__param"><span class="std std-ref">non_contiguous_copy_param</span></a> &amp;copy_params, <strong>gm</strong> int32_t *sig_addr, int32_t signal, int sig_op, int pe)</p>
</div>
<dl class="simple">
<dt><strong>Function Description</strong></dt><dd><p>Asynchronous interface. Provide a high-performance way to copy non-contiguous data on local UB to symmetric address on the specified PE.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><p><ul class="simple">
<li><p><strong>dst</strong> - [in] Pointer on local device of the destination data.</p></li>
<li><p><strong>src</strong> - [in] Pointer on Symmetric memory of the source data.</p></li>
<li><p><strong>copy_params</strong> - [in] Params to describe how non-contiguous data is organized in src and dst.</p></li>
<li><p><strong>sig_addr</strong> - [in] Symmetric address of the signal word to be updated.</p></li>
<li><p><strong>signal</strong> - [in] The value used to update sig_addr.</p></li>
<li><p><strong>sig_op</strong> - [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD</p></li>
<li><p><strong>pe</strong> - [in] PE number of the remote PE. </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__so_8h_1a522423cfe8373be36c2b83a3125ac3b7"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_putmem_signal</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">size_t</span> <span class="pre">elem_size,</span> <span class="pre">__gm__</span> <span class="pre">int32_t</span> <span class="pre">*sig_addr,</span> <span class="pre">int32_t</span> <span class="pre">signal,</span> <span class="pre">int</span> <span class="pre">sig_op,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Synchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE then update sig_addr. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>sig_addr</strong> – [in] Symmetric address of the signal word to be updated. </p></li>
<li><p><strong>signal</strong> – [in] The value used to update sig_addr. </p></li>
<li><p><strong>sig_op</strong> – [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__so_8h_1a36b717559c3d3807f3664c1f81a13f3a"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">void</span> <span class="pre">aclshmem_putmem_signal_nbi</span> <span class="pre">(__gm__</span> <span class="pre">void</span> <span class="pre">*dst,</span> <span class="pre">__gm__</span> <span class="pre">void</span> <span class="pre">*src,</span> <span class="pre">size_t</span> <span class="pre">elem_size,</span> <span class="pre">__gm__</span> <span class="pre">int32_t</span> <span class="pre">*sig_addr,</span> <span class="pre">int32_t</span> <span class="pre">signal,</span> <span class="pre">int</span> <span class="pre">sig_op,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Asynchronous interface. Copy contiguous data on local PE to symmetric address on the specified PE then update sig_addr. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – [in] Pointer on local device of the destination data. </p></li>
<li><p><strong>src</strong> – [in] Pointer on Symmetric memory of the source data. </p></li>
<li><p><strong>elem_size</strong> – [in] Number of elements in the dest and source arrays. </p></li>
<li><p><strong>sig_addr</strong> – [in] Symmetric address of the signal word to be updated. </p></li>
<li><p><strong>signal</strong> – [in] The value used to update sig_addr. </p></li>
<li><p><strong>sig_op</strong> – [in] Operation used to update sig_addr with signal. Supported operations: ACLSHMEM_SIGNAL_SET/ACLSHMEM_SIGNAL_ADD </p></li>
<li><p><strong>pe</strong> – [in] PE number of the remote PE. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="shmem-device-team-h">
<h2>shmem_device_team.h<a class="headerlink" href="#shmem-device-team-h" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a4257017af558991b7bb8cb12b3c7a4f8"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_my_pe</span> <span class="pre">(void)</span></span></dt>
<dd><p>Returns the PE number of the local PE. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Integer between 0 and npes - 1 </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a21ec6c1279158b3927e29d64be9ac9ce"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_n_pes</span> <span class="pre">(void)</span></span></dt>
<dd><p>Returns the number of PEs running in the program. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of PEs in the program. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a1878d13f13d87b6fbf93e6ad4d9d1f28"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_team_my_pe</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team)</span></span></dt>
<dd><p>Returns the number of the calling PE in the specified team. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>team</strong> – [in] A team handle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of the calling PE within the specified team. If the team handle is ACLSHMEM_TEAM_INVALID, returns -1. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a84a5e3246b249256bafbbe810ba7f1aa"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_team_n_pes</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team)</span></span></dt>
<dd><p>Returns the number of PEs in the specified team. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>team</strong> – [in] A team handle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of PEs in the specified team. If the team handle is ACLSHMEM_TEAM_INVALID, returns -1. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a4459e5506ef59bbdd97ae7fb690d1113"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_team_translate_pe</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">src_team,</span> <span class="pre">int</span> <span class="pre">src_pe,</span> <span class="pre">aclshmem_team_t</span> <span class="pre">dest_team)</span></span></dt>
<dd><p>Translate a given PE number in one team into the corresponding PE number in another team. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_team</strong> – [in] A ACLSHMEM team handle. </p></li>
<li><p><strong>src_pe</strong> – [in] The PE number in src_team. </p></li>
<li><p><strong>dest_team</strong> – [in] A ACLSHMEM team handle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of PEs in the specified team. If the team handle is ACLSHMEM_TEAM_INVALID, returns -1. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="shmem__device__team_8h_1a76d26994fa5bcfc72fa6fe8d1649f7a2"></span><span class="sig-name descname"><span class="pre">ACLSHMEM_DEVICE</span> <span class="pre">int</span> <span class="pre">aclshmem_team_pe_mapping</span> <span class="pre">(aclshmem_team_t</span> <span class="pre">team,</span> <span class="pre">int</span> <span class="pre">pe)</span></span></dt>
<dd><p>Translate a given PE number in one team into the corresponding PE number in global team. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>team</strong> – [in] A ACLSHMEM team handle. </p></li>
<li><p><strong>pe</strong> – [in] The PE number in src_team.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of PEs in the global team. If the team handle is ACLSHMEM_TEAM_INVALID, returns -1. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="host_api.html" class="btn btn-neutral float-left" title="HOST API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pythonAPI.html" class="btn btn-neutral float-right" title="SHMEM Python API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright  2025 Huawei Technologies Co., Ltd..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>